## Шаг 1. Подготовка к портированию на NMC 

В коде предыдущего шага присутствует работа с 8-разрядными данными типа char. 
В архитектуре NMC минимально адресуемая ячейка памяти - 32-разрядное слово. Поэтому тип *char* и *short* физически в памяти занимают также 32 бита и 
соответственно наша программа будет работать некорректно. Есть несколько вариантов решения данной проблемы:
* Вариант A  - с помощью переупаковки : 
  - сделать распаковку данных из 8-разрядных массивов в 32-разрядные  
  - произвести вычисление на скалярном процессоре в 32-разрядной арифметике, учитывая, что переменная типа *char* - занимает 32 бита в памяти  
  - произвести упаковку обратно из 32 в 8-разрядные данные  
* Вариант B - с помощью эмуляции байтового доступа  
  - сделать подмену типов: вместо указателей на тип *char* использовать тип *uint8ptr*. Тип *uint8ptr* обеспечивает обращение к отдельным байтам и работу с указателем как если бы это был тип *char** 
* Вариант С - переписать алгоритма ,использую байтовую арифметику на векторном сопроцессоре NeuroMatrix

Каждый способ имеет свои недостатки и преимущества:
- Вариант A. Требует детального изучения кода ,  использования функций упаковки/распаковки,  аккуратной работы с массивами и указателями на тип *char*.
  вычисления производятся на скалярном RISC ядре,  имеют более высокую скорость чем вариант B, но модифицированный код можно использовать только под NMC-платформой, кроссплатформенность с PC - нарушается.
- Вариант B. Требует минимального изучения кода, в большинстве случаев достаточно подмены типов. Код остается переносимым на PC. Однако, в виду эмуляции байтового доступа производительность резко снижается.
  Хорошо использовать для некритичных участков кода или когда требуется получить просто работающий прототип.   
- Вариант С. Требует полного перепрограммирования алгоритма под векторный процессор, однако скорость может возрасти на порядки. 
  
В данном примере рассмотри вариант B, а в последующих шагам перейдем к С


В исходном коде **sobel.cpp** для эмуляции достаточно подменить типы в объявлениях переменных на **uint8ptr**. 
Подмене подлежат только указатели на типа **char**. Необходимые типы подключаем через файл "nmplv/nmchar.h"
Сам же код вычислений остается неизменным **sobel.cpp**: 
```cpp
#include "nmplv/nmchar.h"

short sobelH[9]={
		1,2,1,
		0, 0,0,
		-1,-2,-1};

short sobelV[9]={
		1,0,-1,
		2, 0,-2,
		1,0,-1};

#define MAX(a,b) ((a) < (b) ? (b) : (a))
#define MIN(a,b) ((a) > (b) ? (b) : (a))

void sobel( const unsigned char *_source,unsigned char *_result, int width, int height)
{
	uint8ptr source(_source);
	uint8ptr result(_result);
	

	int j,sum1,sum2;
	// here was: const unsigned char *line1, *line2, *line3;
	uint8ptr line1, line2, line3;
	// here was: unsigned char* res;
	uint8ptr res;

	line1 = source- width -1;
	line2 = line1 + width;
	line3 = line2 + width;

	// here was: const unsigned char* end=source+width*height;
	uint8ptr end=source+width*height;
	
	for(j=0;j<height*width;j++)
	{
		if (line1>source && (line3+2)<end){
		
			sum1  = line1[0]*sobelH[0] + line1[1]*sobelH[1] + line1[2]*sobelH[2] +
					line2[0]*sobelH[3] + line2[1]*sobelH[4] + line2[2]*sobelH[5] + 
					line3[0]*sobelH[6] + line3[1]*sobelH[7] + line3[2]*sobelH[8] ;
			
			sum2  = line1[0]*sobelV[0] + line1[1]*sobelV[1] + line1[2]*sobelV[2] +
					line2[0]*sobelV[3] + line2[1]*sobelV[4] + line2[2]*sobelV[5] + 
					line3[0]*sobelV[6] + line3[1]*sobelV[7] + line3[2]*sobelV[8] ;
			

			sum1=(sum1>0)?sum1:-sum1;
			sum2=(sum2>0)?sum2:-sum2;
			
			*result=MIN(255,sum1+sum2);
		}
		result++;
		line1++;
        line2++;
        line3++;
	}
}

```
Результат работы программы на PC остался тем же, но программа полностью подготовлена для запуска на NMC.
