## Шаг 2. Портирование. Запуск программы на NMC 

На предыдущем шаге мы подготовили исходные тексты для переноcа на NMC.
Рассмотрим два варианта портирования проекта под NMC :  
- Создание standalone-приложения . В зависимости от целевой платы nmc-приложение запускается с помощью специальной программы-загрузчика (mb7707run/mc5103run/mc7601run/nm6405emurun...) . 
  
- Создание приложение с управляющей хостовой частью программы на PC.

### Создание standalone-nmc-приложения

#### Схема работа приложения
- Приложение запускается загрузчиком (например mb7707run). Перед входом в функцию *main()*
  загрузчик пишет изображение **Lena224x240.pgm** в разделяемую область памяти (адрес загрузки задается ключом --send_addr.)   
- Программа стартует и узнает этот адрес через макрос *EXCH_ZONE* файла **memcfg.h**.   
- Далее программа  с адреса *EXCH_ZONE* читает заголовок изображение в формате PGM.   
- Выделяются выходные и выходные буфера *src* и *dst* для функции *sobel* с помощью *malloc32*  
- Так как сами данные изображения могут начинаться с произвольного байта, то для начала их необходимо выровнить, 
скопировав в другую область (*src*) по выровненной 64-разрядной границе, например с помощью векторной функции *VEC_Copyua*.  
- Вызывается функция *sobel*  
- Результат (*dst*) побайтно копируется обратно в PGM контейнер на место исходного изображения (*EXCH_ZONE*) с помощью функций VEC_GetVal и VEC_SetVal  
- По окончанию работы функции *main* загрузчик читает область памяти по адресу указанному в ключе  --recv_addr и сохраняет в результирующий файл *Sobel.pgm*


#### Настройка  и сборка проекта 
Сборка и запуск проекта осуществляется через Makefile.
в Makefile  указываем необходимые пути к заголовочным файлам и библиотекам:  
```mk
INC_DIRS         = -I"$(NEURO)/include" -I"$(MB7707)/include" -I"$(NMPP)/include" -I. -I../.. -I$(ROOT)/deps/EasyPGM
LIB_DIRS         = -L"$(NEURO)/lib" -L"$(MB7707)/lib" -L"$(NMPP)/lib"
```
Указываем библиотеки
```mk
LIBS             = libint_soc.lib mb7707lib.lib libc05.lib cppnew05.lib nmpp_nmc3.lib
```
Исходники указываются в виде относительных путей. Все имеющиеся .c и .cpp файлы в этих каталогах будут автоматически подключены в проект
```mk
SRC_DIRS         = .. ../.. $(ROOT)/deps/EasyPGM
```

Указываем опции линкера и размеры куч:
```mk
BUILDER_FLAGS    = -cmb7707brd.cfg -m  -heap=554432 -heap1=0 -heap2=0 -heap3=0 -full_names -o$(TARGET) $(LIB_DIRS)
```

Запуск приложения осуществляется командой *make run* согласно правилу:
```mk
run: $(TARGET)
	$(MB7707)/bin/mb7707run -i -a$(MB7707_MAC) $(TARGET) --send_file_name=$(ROOT)/input/Lena224x240.pgm --send_addr=0x10000000 --recv_file_name=Sobel.pgm --recv_addr=0x10000000 --recv_size=0x348a
```
> MB7707_MAC - необходимо установить соответственно адресу вашей сетевой карты. 
> В дальнейшим в примерах c хост частью будет использоваться адрес 1a-2b-3c-4d-5e-6f, для удобства рекомендуется выставить такой же MAC адрес для сетвой карты.


В конфигурационном файле (mb7707brd.cfg) резервируем область разделяемой памяти в 4MB для передачи изображения загрузчиком начиная с 0x10000000 по 0x10100000:
```
	EXTERNAL_MEM_PGM: 	at 	0x10000000, 	len = 0x10100000;	// 4 MB
	EXTERNAL_MEMORY0: 	at 	0x10100000, 	len = 0x01F00000;	// 128MB-EM0-DDR 	(ARM:0x40000000	0x7fffffff) 
	EXTERNAL_MEMORY1: 	at 	0x30000000, 	len = 0x02000000;	// 128MB-EM1-DDR 	(ARM:0xc0000000	0xffffffff) 
```




### Создание приложения с хостовой частью. 

Проект состоит из двух частей - хостовой /mb7707/pc и целевой /mb7707/nm.  
Хостовая часть необходима для:  
- загрузки исполняемого nmc-кода на МС77.07 
- чтения  файла src.bmp  
- загрузки ч/б изображения на плату  
- считывание результата обработки с платы  
- сохранения результата в dst.bmp  

Целевая часть ждет получения изображения от хоста и обрабатывает его фильтром Собеля 

Общие файлы, которые также используются в других сборках , например для мс5103 или целиком модели на хосте,
лежат в корне папки /step02_easybmp_risc

#### Создаем nmc-приложение
Работа nmc-практически отличается от standalone приложения, только тем, что файл изображения разбирается на стороне хоста и передается на nmc-часть в виде массива пикслей.
Для барьерной синхронизации используются функции библиотеки загрузки и обмена *ncl_sync* на стороне nmc и их ответные функции PL_Sync на стороне PC,  обернутые для удобства *C_PC_Connector_mc5103::Sync*

Отличия в сборке состоят только в конфигурационном файле - в данном случае нет необходимости резервировать область памяти в 4MB.

#### Создаем host-приложение
Аналогично прописываем пути в Makefile для хост приложения
```
INC_DIRS         = -I"$(MB7707)/pc/include" -I$(ROOT)/deps/connector -I$(ROOT)/deps/EasyBMP
LIB_DIRS         = -L"$(MB7707)/pc/lib"
SRC_DIRS         = .. $(ROOT)/deps/EasyBMP
LIBS             = mb7707load.lib
```
Работу с bmp файлами осуществляем через библиотеку EasyBMP
Доступ к плате для удобства осуществляется через класс C_PC_Connector_mb7707 , на вход конструктора которого необходимо передать имя исполняемого плата и MAC адрес сетевого контролера к которому подсоединена плата.

Так как функция **malloc** на хосте принимает размер в байтах, а на стороне nmc- в 32р.-словах, 
то для переносимости когда мы вынуждены стандартный вызов **malloc** на nmc обернуть в функцию **malloc32**, в которой размер передается в 32-разрядных словах и дальше использовать только его. 

```cpp
void* malloc32(unsigned size_int32 )
{
#ifdef __NM__
	return malloc(size_int32); 
#else
	return malloc(size_int32*4);
#endif
}
```
>Выделение памяти будет происходить из секции *heap* во внешний памяти согласно конфигурационному файлу.
>Запуск программы осуществляется через *make run* их папки mb7707/pc/make_vs08 или mb7707/pc/make_vs13 в зависимости от версии Visual Studio.

В результате исполнения в этой же папке должен появиться dst.bmp

#### Производительность: 
- 1203625826 clocks per frame 
- 14247 clocks per pixel
- 0.265863 fps




 



