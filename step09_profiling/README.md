## Шаг 9. Профилирование 

Для оценки производительности функции мы использовали функции clock. Приступая к более глубокой оптимизации нам небходимо знать время затраченной каждой функцией .
Для этих целей можно воспользоваться библиотекой профилирования . Подключение профилировщика осуществляется подключением одного единственного файла proflist_generated.asm, 
в котором указываются полные имена функций, подлежащих профилированию.

Автоматически сгенерировать этот список вместе с самим файлом можно по уже имеющемуся map-файлу с помощью команды make profile .
После сборки и линковки proflist_generated.asm библиотека автоматически инициализируется и стартует. 

Чтобы вывести результат профилирования , со стороны хост программы достаточно вызывать функцию 

```cpp
	...
	profiler_print2tbl("../../nm/sobel_mb7707_nmd.map", ReadMemBlock);
	...
```

на вход которой необходимо передать map-файл, по которому будет найдет местоположение результатов профилирования
и функцию с помощью которой будет осуществляться чтение этих данных:

```cpp		
#include "profiler_access.h"
PL_Access* access;
int ReadMemBlock(void* host_dst, unsigned nmc_addr, unsigned size32){
	return PL_ReadMemBlock(access,(PL_Word*)host_dst, (PL_Addr)nmc_addr, size32);
}
```	
	
 

За счет накладных расходов на профилирлование проивзодтельность функции уменьшится .
-18721453 clocks per frame
-45.14 clocks per pixel
-17.09 fps

а результат профилирования можно наблюдать в следующем виде :
![Рис.1](http://savepic.ru/7354995.png "Результат профилирования")
- Столбец 1 - общее время работы функции (в тактах)
- Столбец 2 - количество вызовов 
- Столбец 3 - усредненное время одного вызова 
- Столбец 4 - физический адрес функции 
- Столбец 5 - название функции









