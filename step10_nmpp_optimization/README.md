## Шаг 10. Оптимизация векторных функций 

*На этом шаге ускорим некоторые библиотечные функции*

###  Ускоряем VEC_Add4V
В функции VEC_Add4V(lines, verticalOut, size)  происходит суммирования 4 массивов. Т.е. производится 4 операции чтения и одна запись. При чем два вектора у нас одинаковых. 
Так как операцию удвоения мы можем производить "на лету " вместе с чтением, то перепишем эту функцию , в которой будет уже три операции чтения:
```cpp
VEC_Add2VW (horizontTmp, horizontTmpUpLine,horizontTmpDnLine,verticalOut, size);
```

Основной рабочий цикл новой функции будет выглядеть так:
```cpp
	...
	<next_MulVN_rep32>
		rep 32 data = [ar0++gr0] with vsum ,data,0;  	// чтение первого вектора и умножение его на 2
		rep 32 data = [ar1++gr1] with afifo + data;		// суммирование со вторым вектором
	if <>0 delayed goto next_MulVN_rep32 with gr5--;	// счетчик
		rep 32 data = [ar2++gr2] with afifo + data;		// суммирование со третьим вектором
		rep 32 [ar6++gr6] = afifo; 						// запись результата в память
	...
```

### Ускоряем VEC_Abs;	
Функция VEC_Abs работает примерно со скоростью 0.5 такта на 16-разрядное число. 
Эту функцию можно заменить на более быстродействующую VEC_Abs1. Для отрицательных значений эта функция возвращает результат, отличающийся от истинного на 1 в сторону 0. 
Т.е. ABS(-3)=2; Однако, в задачах видеобработки такая погрешность несущественна, а скорость функции за счет особенностей векторного процессора вдове выше, поэтому в дальнейшем будем использовать ее.


### Объединяем VEC_ClipPowC и VEC_Cnv 
Вместо двух функций VEC_ClipPowC (0,25 tick/pix) и VEC_Cnv(0,25 tick/pix)  за счет аппаратных возможностей векторного узла мы можем использовать одну VEC_ClipCnv_AddC (0,25 tick/pix)

### Запуск
В результате данной оптимизации мы получили прирост производительности на 18%: 
- 2329266 clocks per frame
- 5.62 clocks per pixel
- 137.38 fps









