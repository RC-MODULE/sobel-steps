## Шаг 10. Оптимизация векторных функций 

*На этом шаге ускорим некоторые библиотечные функции*

###  Ускоряем nmppsAdd4V_16s
В функции nmppsAdd4V_16s(lines, verticalOut, size)  происходит суммирования 4 массивов. Т.е. производится 4 операции чтения и одна запись. При чем два вектора у нас одинаковых. 
Так как операцию удвоения мы можем производить "на лету " вместе с чтением, то перепишем эту функцию , в которой будет уже три операции чтения:
```cpp
add2VW (horizontTmp, horizontTmpUpLine,horizontTmpDnLine,verticalOut, size);
```

Основной рабочий цикл новой функции будет выглядеть так:
```cpp
	...
	<next_MulVN_rep32>
		rep 32 data = [ar0++gr0] with vsum ,data,0;  	// чтение первого вектора и умножение его на 2
		rep 32 data = [ar1++gr1] with afifo + data;		// суммирование со вторым вектором
	if <>0 delayed goto next_MulVN_rep32 with gr5--;	// счетчик
		rep 32 data = [ar2++gr2] with afifo + data;		// суммирование со третьим вектором
		rep 32 [ar6++gr6] = afifo; 						// запись результата в память
	...
```

### Ускоряем nmppsAbs_16s;	
Функция nmppsAbs_16s работает примерно со скоростью 0.5 такта на 16-разрядное число. 
Эту функцию можно заменить на более быстродействующую nmppsAbs_16s1. Для отрицательных значений эта функция возвращает результат, отличающийся от истинного на 1 в сторону 0. 
Т.е. ABS(-3)=2; Однако, в задачах видеобработки такая погрешность несущественна, а скорость функции за счет особенностей векторного процессора вдове выше, поэтому в дальнейшем будем использовать ее.


### Объединяем nmppsClipPowC_16s и nmppsConvert_32s8s 
Вместо двух функций nmppsClipPowC_16s (0,25 tick/pix) и nmppsConvert_32s8s(0,25 tick/pix)  за счет аппаратных возможностей векторного узла мы можем использовать одну nmppsClipConvertAddC_16s8s (0,25 tick/pix)

### Запуск
В результате данной оптимизации мы получили прирост производительности на 18%: 
- 2329266 clocks per frame
- 5.62 clocks per pixel
- 137.38 fps









