## Шаг 12. Оптимизация фильтра выделения вертикальных границ 

Для вычитания массива из самого себя смещенного на две строки мы использовали функцию разности двух векторов -**VEC_SubV**. 
Однако, учитывая тот факт, что вычитаемые вектора принадлежат одному и тому же массиву, можно использовать другую схему, подобную 
фильтру с вертикальным окном из коэффициентов (-1,0,1)

Реализуем на ассемблере функцию фильтрации с вертикальным окном из 3 элементов . см.файл *filter3v.asm*.
>Ограничением полученной функции является то, что высота фильтруемого изображения должна быть кратна 30.
>Это обусловлено тем что в ходе исполнения инструкций rep32 на 32 считанных слов приходится только 30 результирующих. 

###  Используем filter3v вместо nmppsSub_16s
Заменяем операцию вычитания двух массивов **nmppsSub_16s** функций фильтрацией **filter3v** с коэффициентами (-1,0,1). 
```cpp
	...
	//nmppsSub_16s(horizontTmpUpLine, horizontTmpDnLine, horizontOut, size);
	filter3v(horizontTmpUpLine, horizontOut,  width, height, sobel_weights101v);
	...
```


###  Используем filter3v вместо add2VW
Аналогичным образом поступаем с функцией add2VW.  
Заменяем операцию суммирования двух массивов и одного удвоенного **add2VW** на фильтрацию **filter3v** с коэффициентами (1,2,1). 
```cpp
	...
	//add2VW (horizontTmp, horizontTmpUpLine,horizontTmpDnLine,verticalOut, size);
	filter3v((nm16s*)horizontTmpUpLine, verticalOut, width, height, sobel_weights121v);
	...
```

### Запуск
В результате данной оптимизации мы получаем прирост скорости в 13%: 
- 1783640 clocks per frame
- 4.30 clocks per pixel
- 179.41 fps








