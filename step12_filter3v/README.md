## Шаг 12. Оптимизация фильтра выделения вертикальных границ 
Рабочий каталог *\step12_filter3v*


Для вычитания массива из самого себя смещенного на две строки мы использовали функцию разности двух векторов -**VEC_SubV**. 
Однако, учитывая тот факт, что вычитаемые вектора принадлежат одному и тому же массиву, можно использовать другую схему, подобную 
фильтру с вертикальным окном из коэффициентов (-1,0,1)

Реализуем на ассемблере функцию фильтрации с вертикальным окном из 3 элементов . см.файл *filter3v.asm*.
>Ограничением полученной функции является то, что высота фильтруемого изображения должна быть кратна 30.
>Это обусловлено тем что в ходе исполнения инструкций rep32 на 32 считанных слов приходится только 30 результирующих. 

###  Используем filter3v вместо VEC_SubV
Заменяем операцию вычитания двух массивов **VEC_SubV** функций фильтрацией **filter3v** с коэффициентами (-1,0,1). 
```cpp
	...
	//VEC_SubV(horizontTmpUpLine, horizontTmpDnLine, horizontOut, size);
	filter3v(horizontTmpUpLine, horizontOut,  width, height, sobel_weights101v);
	...
```


###  Используем filter3v вместо VEC_Add2VW
Аналогичным образом поступаем с функцией VEC_Add2VW.  
Заменяем операцию суммирования двух массивов и одного удвоенного **VEC_Add2VW** на фильтрацию **filter3v** с коэффициентами (1,2,1). 
```cpp
	...
	//VEC_Add2VW (horizontTmp, horizontTmpUpLine,horizontTmpDnLine,verticalOut, size);
	filter3v((nm16s*)horizontTmpUpLine, verticalOut, width, height, sobel_weights121v);
	...
```

### Запуск
В результате данной оптимизации мы получаем прирост скорости в 13%: 
- 1783640 clocks per frame
- 4.30 clocks per pixel
- 179.41 fps








