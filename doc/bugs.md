Припарировать багов за три такта
Боремся с багами на Neuromatrix или как фильтр Собеля менее за три такта.

Для разработчка при выборе  аппаратную платформу для реализации своей задач, важно не только представлять какеи технические возможности предоставляет архитектра , 
но и иметь представление как выглядит процесс разработки, оптимизации, портирование уже готовых проектов,  какие  средства разработки имеются в распоряжеии.
На начальном этапе  больше значение имеет даже не сколько специфика процессора и его программирование , а сколько создание рабочего окружение, настройки иснтрументария. 

В данной статье мы поробуй провести "мост" между пользователем далким от NeuroMatrix, но с уже имеющейся задачай и аппаратным железом , на которую ее необходимо переложить. 
Также будет показаны стадии эволюции проекта и соотвествующий рост его производительности, что даст более полное понимание пределов возможностей процессора . 

На данном примерых ввтором предлагается технология разработки сложных алгоритимческих проектов . 

Будем рассматривать постепенное погружение в NeuroMatrix на цепочке шагов. Начиная от запуска имющейся поведенческой модели на С++ , до высоко-оптимизированного кода на ассемблере. 
В качестве примера будем использовать широко известный и популярный в цифровой обработке сигналов фильтр Собеля. 
В нашей цепочке будет несоклько ключевых точек. 
1 - Портирование и Запуск С++ модели на RISC NMC 
2 - Подключние библиотечных функций для задействование вектороного сопроцессора
4 - Оптимизиция с учетом архитектурных особенностей процессора
3 - Оптимизация отдельных функций на уровне ассемблера. 

Каждый шаг будет иметь более мелкие подшаги.  каждый шаг является по сути законченным проектов , и при достаточной проивзодиельности не требует дальшей потимизации 
Но в целях демонстрации будет показан полный цикл разработки.  Автор также придерживается именно поэтапной стратегии оптимизации , нежели разарботки сразу выскооптимизированного кода.
Это дает более надежный код и точки отката. 

1-ый шаг прототипирование 
У нас есть математическая форма фильтра Собеля, реализуем ее прототип для хоста в среде Microsoft Visual Studio 8 и Microsoft Visual Studio 13.   
Согласно определению оператора [Собеля](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D0%A1%D0%BE%D0%B1%D0%B5%D0%BB%D1%8F) имеем следующий код **sobel.cpp**: 
```cpp
short sobelH[9]={
		1, 2, 1,
		0, 0, 0,
		-1,-2,-1};

short sobelV[9]={
		1, 0, -1,
		2, 0, -2,
		1, 0, -1};

void sobel( const unsigned char *source, unsigned char *result, int width, int height)
{
	int j,sum1,sum2;
	const unsigned char *line1, *line2, *line3;
	line1 = source- width -1;
	line2 = line1 + width;
	line3 = line2 + width;
	const unsigned char* end=source+width*height;
	
	for(j=0; j<height*width; j++){
		if (line1>source && (line3+2)<end){
			sum1  = line1[0]*sobelH[0] + line1[1]*sobelH[1] + line1[2]*sobelH[2] +
					line2[0]*sobelH[3] + line2[1]*sobelH[4] + line2[2]*sobelH[5] + 
					line3[0]*sobelH[6] + line3[1]*sobelH[7] + line3[2]*sobelH[8] ;
			
			sum2  = line1[0]*sobelV[0] + line1[1]*sobelV[1] + line1[2]*sobelV[2] +
					line2[0]*sobelV[3] + line2[1]*sobelV[4] + line2[2]*sobelV[5] + 
					line3[0]*sobelV[6] + line3[1]*sobelV[7] + line3[2]*sobelV[8] ;
			
			sum1=(sum1>0)?sum1:-sum1;
			sum2=(sum2>0)?sum2:-sum2;
			*result=MIN(255,sum1+sum2);
		}
		result++;
		line1++;
        line2++;
        line3++;
	}
}
```


 



этапе мы будет получать ускорение . 




 



Руководство предназначено для ознакомления с программированием процессоров сеймейства NeuroMatrix, работой с инструментальными платами МВ77.07 и МС5103.
Описывается процесс последовательной модификации DSP-приложения в виде серии шагов начиная от запуска простой поведенческой С++ модели 
до разработки высоко-оптимизированного кода под векторный сопроцессор.
В качестве примера используются широко применяемый в области ЦОС фильтр Собеля.


*Step by step DSP application development for NeuroMatrix . There are examples of filter Sobel  starting from simple C++ model to high-optimized application using NeuroMatrix vector co-processor*

Предлагаемая серия шагов является избыточной с точки зрения реального построения программ, однако позволяет лучше понять нюансы программирования под NeuroMatrix ,
представить возможности архитектуры, а также имеющихся средств разработки.  
В процессе изучения будут рассмотрены следующие вопросы:
- Изучение способов портирования готовых приложений с x86 плафтормы на NMC
- Обеспечение кроссплафторменности исходных текстов. 
- Запуск приложений в автономном режиме для плат МЦ5103 и MB7707 
- Запуск приложения под управлением хост-программы для плат МЦ5103 и MB7707
- Работа с графической оболочки VSHELL для упрощения разработки и отладки ЦОС-приложений 
- Запуск программного кода на RISC-ядре
- Подключение векторной библиотеки NMPP и перенос кода на векторный сопроцессор
- Оптимизация алгоритма, ускорение кода - разработка спец. функций на ассемблере 
- Модификации алгоритма - перенос обработки из внешней памяти - в быструю внутреннюю
- Профилирование
- Распараллеливание потоков данных по внутренним банкам памяти.  
- Работа с видеопамятью MB7707 , вывод изображения на телевизор через HDMI

## Пошаговая установка и сборка
Установка состоит из трех пунктов:
- Установка библиотек и средств разработки 
- Загрузка  видеороликов 
- Сборка примеров и запуск

### Установка библиотек и средств разработки 
Данный проект <sobel-steps> имеет несколько зависимостей от библиотек и системного ПО:
- nmsdk (SDK для сборки программ под NMC)
- mc5103sdk (по поддержки для платы МЦ5103)
- mc7601sdk (по поддержки для платы МЦ7601)
- mb7707sdk (по поддержки для платы МВ77.07)
- nmpp (Библиотека векторно-матричных функций на процессорах семейства NeuroMatrix)
- nmprofiler (библиотека профилирования)
- vshell32 (графическая оболочка для разработки видеоприложений под Windows)

Хотя некоторые пакеты могут изначально присутствовать, для обеспечения совместимости версий и
упрощения процедуры настройки все зависимые компоненты подгружаются через интернет с сайта разработчика в локальную папку
*/sobel-steps/deps* и дальше вызываются оттуда. При этом никаких изменений переменных окружения в системе не требуется и не производится.
Локальное переопределение переменных производится в файле */sobel-steps/environment.mk*
 
Скачать и установить все необходимые компоненты можно командой командами
```bat
make download 
make install
```

Для корректного исполнения сборочных Makefile-скриптов под Windows необходимо, чтобы были установлены следующие утилиты:
- **Make for Windows**. [Скачать инсталлятор](http://gnuwin32.sourceforge.net/downlinks/make.php). Домашняя страница: http://gnuwin32.sourceforge.net/packages/make.htm


> Альтернативными утилитами для скачивания и распаковки под Windows могут являться **wget** и **unzip**.
> В файле */sobel-steps/environment.mk* через переменные OS_WGET и OS_UNZIP можно настроить способ скачивания и распаковки 
- **Wget for Windows**. [Скачать инсталлятор](http://downloads.sourceforge.net/gnuwin32/wget-1.11.4-1-setup.exe). Домашняя страница http://gnuwin32.sourceforge.net/packages/wget.htm
- **UnZip for Windows** [Скачать инсталлятор](http://gnuwin32.sourceforge.net/downlinks/unzip.php). Домашняя страница http://gnuwin32.sourceforge.net/packages/unzip.htm  
> Утилиты должны быть доступны через переменную окружения PATH.  
> Пути к **wget** и **unzip** можно не прописывать в PATH если при их установке была указана папка */sobel-steps/gnuwin32*


В приведенных шагах могут присутствовать несколько вариантов работы с отладочными модулями: 
- полностью автономное (standalone) приложение , запускаемое средствами ПО поддержки плат.
- двух-компонетные приложения (host-target), где загрузка и управление NMC-программой на плате
 осуществляется со стороны хост-программы, разработанной на С++ в среде Microsoft Visual Studio (2005 или 2013)

Соответственно для второго варианта также требуется установленная версия Miсrosoft Visual Studio 
 * [Visual Studio 2005 Express](http://apdubey.blogspot.ru/2009/04/microsoft-visual-studio-2005-express.html)
 * [Visual Studio 2013 Express](https://www.microsoft.com/en-US/download/details.aspx?id=44914)  

> Драйвера плат (MC5103,МВ77.07,МС7601..)   предполагается уже установлены пользователем 
 
### Загрузка  видеороликов 
 
В качестве тестовых данных используются изображения в формате bmp, pgm и видеоролики .
Тестовые видео-ролики подгружаются отдельно в папку  */sobel-steps/input* командой 
```bat
make avi
```
  

### Сборка и запуск
1. Запуск host-target приложения (с автоматической сборкой nm и pc части) осуществляется командой
```mak
 make run
```
  из соответствующий папки хостовой части приложения, например *mb7707/pc/make_vs08*  
2. Запуск автономного(standalone) приложения  осуществляется также командой 
```mak
make run
```
из соответствующий папки */standalone*  
3. При работе с платой MB77.07 в *pc/main.cpp* необходимо переопределить MAC-адрес сетевого адаптера подключенного к плате.
 А при работе с платой в автономном режиме MAC-адрес требуется задать в */sobel-steps/environment.mk*. По умолчанию используется:
```cpp
  unsigned char MAC_ADDRESS[] = {0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f}
```
4. Убедиться, что перемычка на плате MB77.07 установлена (Загрузка OS Linux - не производится). 


>Осуществить сборку всех примеров можно командой 
>```mak
>  make steps
>```	


## Автоматическая установка и сборка
Также осуществить установку проекта , включающую все описанные выше шаги, и запустить сборку всех примеров можно одной командой 
```mak
  make
```	


### Содержание 
#### Шаг 0. [Реализация прототипа фильтра Собеля для хоста ](/step00_easybmp_prototype/)
 Рассматривается поведенческая модель. Запуск на хосте.
#### Шаг 1. [Подготовка к портированию на NMC](/step01_easybmp_port2nmc/)
 Адаптация кода для обеспечения кроссплатформенности 
#### Шаг 2. [Портирование. Запуск программы на NMC](/step02_easybmp_risc/)
 Осуществляется запуск модели на хосте, на RISC ядре процессора NMC на платах MB77.07 и МС5103
#### Шаг 3. [Портирование алгоритма на векторный процессор](/step03_easybmp_nmpp/)
  Используем векторные функции из состава NMPP 
#### Шаг 4. [Подключение графической оболочки VSHELL ](/step04_vshell_nmpp/)
 Переход от единичной обработки к покадровой используя графическую оболочку VSHELL
#### Шаг 5. [Оптимизация градиентных фильтров  ](/step05_filter_optimization/)
 Переход от двумерной фильтрации к одномерной 
#### Шаг 6. [Оптимизация динамического выделения памяти ](/step06_class/)
 Использование классов.
#### Шаг 7. [Модификация программы для работы во внутренней памяти nmc](/step07_internal_memory/)
 Переход к кусочной обработке изображения во внутренней памяти.
#### Шаг 8. [Устранение граничных дефектов кусочной обработки](/step08_edge_removal/)
#### Шаг 9. [Профилирование](/step09_profiling/)
#### Шаг 10. [Оптимизация векторных функций ](/step10_nmpp_optimization/)
#### Шаг 11. [Оптимизация фильтра выделения горизонтальных границ ](/step11_filter3h/)
#### Шаг 12. [Оптимизация фильтра выделения вертикальных границ ](/step12_filter3v/)
#### Шаг 13. [Распараллеливание входных и выходных потоков данных ](/step13_memory_optimization/)
#### Шаг 14. [Определение пиковой производительности](/step14_max_performance/)
#### Шаг 15. [HDMI вывод на экран в SD разрешении](/step15_hdmi_sd/)
#### Шаг 16. [HDMI вывод на экран в HD разрешении](/step16_hdmi_hd/)


 