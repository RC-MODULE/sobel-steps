## Шаг 1. Портирование С++ кода на NMC RISC-ядро с эммуляцией байтого доступа

*В данном уроке подготовим приложение к переносу на NMC*  

В коде предыдущего шага присутствует работа с 8-разрядными данными типа char. 
Так как в архитектуре NMC минимально адресуемая ячейка памяти - 32-разрядное слово, то тип **char** и **short** физически в памяти занимают также 32 бита.
Поскольку изображение хранится побайтно, то из-за несоответствия разрядностей типов исходная программа будет работать некорректно. Есть несколько вариантов решения данной проблемы:  
* Вариант A  - с помощью переупаковки : 
  - сделать предварительную  переупаковку данных из 8-разрядных данных в 32-разрядные  
  - произвести вычисления на скалярном процессоре в 32-разрядной арифметике, учитывая, что переменная типа *char* - занимает 32 бита в памяти  
  - произвести упаковку обратно из 32 в 8-разрядные данные  
* Вариант B - с помощью эмуляции байтового доступа  
  - сделать подмену типов внутри функции *sobel*: вместо указателей на тип **char** использовать тип **uint8ptr**. 
  Тип **uint8ptr** обеспечивает обращение к отдельным байтам и работу с указателем как если бы это был обычный 8-разрядный тип **char*** 
* Вариант С - переписать алгоритм, используя байтовую арифметику на векторном сопроцессоре NeuroMatrix

Каждый способ имеет следующие недостатки и преимущества:
- Вариант A.  
  Требует детального изучения кода,  использования функций упаковки/распаковки,  аккуратной работы с массивами и указателями на элементы массива.
  Скомпилированный код С/C++ исполняется на скалярном RISC ядре имеют  среднюю относительную производительность. В ощем случае (за счет преобразования разрядностей ) кроссплатформенность между NMC и PC - нарушается.
- Вариант B.  
  Требует минимального изучения кода, в большинстве случаев достаточно подмены типов. С/C++ код остается переносимым на PC. Однако, в виду эмуляции байтового доступа производительность резко снижается по сравнению с вариантом А.
  Хорошо использовать для некритичных участков кода или когда требуется быстро получить работающий прототип.   
- Вариант С.  
  Требует полного перепрограммирования функций алгоритма под векторный процессор на ассемблере, либо использование готовых библиотечных функций, однако скорость может возрасти на порядки. 
  Переносимость алгоритма на PC обеспечивается наличием или разработкой аналогичных функций для PC. 

## Шаг 1-а. Подготовка кода. Запуск на PC

В данном примере рассмотрим вариант B, а в последующих шагам перейдем к А и С.


В исходном коде **sobel.cpp** для эмуляции достаточно подменить типы в объявлениях переменных на **uint8ptr**. 
Подмене подлежат только указатели на тип **char**. Необходимые типы подключаем через файл "nmplv/nmchar.h"
Сам же код вычислений остается неизменным **sobel.cpp**: 
```cpp
#include "nmplv/nmchar.h"

short sobelH[9]={
		1,2,1,
		0, 0,0,
		-1,-2,-1};

short sobelV[9]={
		1,0,-1,
		2, 0,-2,
		1,0,-1};

#define MAX(a,b) ((a) < (b) ? (b) : (a))
#define MIN(a,b) ((a) > (b) ? (b) : (a))

void sobel( const unsigned char *_source,unsigned char *_result, int width, int height)
{
	uint8ptr source(_source);
	uint8ptr result(_result);
	

	int j,sum1,sum2;
	// here was: const unsigned char *line1, *line2, *line3;
	uint8ptr line1, line2, line3;
	// here was: unsigned char* res;
	uint8ptr res;

	line1 = source- width -1;
	line2 = line1 + width;
	line3 = line2 + width;

	// here was: const unsigned char* end=source+width*height;
	uint8ptr end=source+width*height;
	
	for(j=0;j<height*width;j++)
	{
		if (line1>source && (line3+2)<end){
		
			sum1  = line1[0]*sobelH[0] + line1[1]*sobelH[1] + line1[2]*sobelH[2] +
					line2[0]*sobelH[3] + line2[1]*sobelH[4] + line2[2]*sobelH[5] + 
					line3[0]*sobelH[6] + line3[1]*sobelH[7] + line3[2]*sobelH[8] ;
			
			sum2  = line1[0]*sobelV[0] + line1[1]*sobelV[1] + line1[2]*sobelV[2] +
					line2[0]*sobelV[3] + line2[1]*sobelV[4] + line2[2]*sobelV[5] + 
					line3[0]*sobelV[6] + line3[1]*sobelV[7] + line3[2]*sobelV[8] ;
			

			sum1=(sum1>0)?sum1:-sum1;
			sum2=(sum2>0)?sum2:-sum2;
			
			*result=MIN(255,sum1+sum2);
		}
		result++;
		line1++;
        line2++;
        line3++;
	}
}

Наша функция готова к портированию на NMC. 
С учетом нюансов в типах данных наши исходные тексты будем создавать кросплатформенными. 
Это позволит упросить отладку и перенос программ на NMC. 
Для начала модифицируем наш проект от шага-0 для PC . )
Запустим программу через 
```cpp
make run
```
Результат работы программы на PC остался тем же, наша программа полностью подготовлена для запуска на NMC в следующем щшаге . 

##  Портирование. Запуск программы на NMC 

*В данном уроке создадим  проект и запустим приложение на NMC*  


На предыдущем шаге мы подготовили исходные тексты для переноcа на NMC.  
Рассмотрим два варианта портирования проекта под NMC:  
- standalone-приложение. Создается исполняемый файл только для NMC. В зависимости от целевой платы NMC-приложение запускается с помощью специальной программы-загрузчика (mb7707run/mc5103run/mc7601run/nm6405emurun...) . 
- Приложение с управляющей хостовой частью программы на PC и вычислительной на NMC.

### Шаг 1-b. Создание standalone-NMC-приложения

#### Схема работа приложения
- В **main.cpp** создаются входной и выходной буфера, где с помощью прагм массивы привязываются к секциям для внешнего обмена данными:   
```cpp
#pragma data_section ".data_shared_src.bss"
	long long src_pgm_file[1920*1080/8+64/8];
#pragma data_section ".data_shared_dst.bss"
	long long dst_pgm_file[1920*1080/8+64/8];
```
- В конфигурационном файле задается расположение этих секций в разделяемой памяти, доступной для загрузчика. 
- Приложение запускается загрузчиком (например mb7707run). 
- До момента передачи управления в функцию *main()* загрузчик пишет исходное изображение **Lena224x240.pgm** в секцию **.data_shared_src.bss** , соответствующую входному массиву **src_pgm_file** (адрес загрузки задается ключом --send_sect) 
- Далее программа стартует и читает входной заголовок изображение в формате PGM (read_pgm_header)  
- Создается результирующий заголовок изображение в формате PGM (save_pgm_header)
- Определяются адреса **src** и **dst** непосредственно данных изображений после PGM-заголовков.  
- Вызывается функция **sobel**
- По окончанию работы функции **main** загрузчик читает область памяти из секции **.data_shared_dst.bss**  и сохраняет ее в результирующий файл *Sobel.pgm*


#### Настройка  и сборка проекта 
Сборка и запуск проекта осуществляется через Makefile.  
В Makefile  указываем необходимые пути к заголовочным файлам и библиотекам:  
```mk
INC_DIRS         = -I"$(NEURO)/include" -I"$(MB7707)/include" -I"$(NMPP)/include" -I. -I../.. -I$(ROOT)/deps/EasyPGM
LIB_DIRS         = -L"$(NEURO)/lib" -L"$(MB7707)/lib" -L"$(NMPP)/lib"
```
Указываем библиотеки
```mk
LIBS             = libint_soc.lib mb7707lib.lib libc05.lib cppnew05.lib nmpp_NMC3.lib
```
Исходные тексты задаются в виде относительных путей к ним. Все имеющиеся .c и .cpp файлы в этих каталогах будут автоматически подключены в проект
```mk
SRC_DIRS         = .. ../.. $(ROOT)/deps/EasyPGM
```

Указываем опции линкера и размеры куч:
```mk
BUILDER_FLAGS    = -cmb7707brd.cfg -m  -heap=554432 -heap1=0 -heap2=0 -heap3=0 -full_names -o$(TARGET) $(LIB_DIRS)
```

Запуск приложения осуществляется командой *make run* согласно правилу:
```mk
run: $(TARGET)
	$(MB7707)/bin/mb7707run -i -a$(MB7707_MAC) $(TARGET) --send_file_name=$(ROOT)/input/Lena224x240.pgm --send_sect=.data_shared_src.bss --recv_file_name=Sobel.pgm --recv_sect=.data_shared_dst.bss  --recv_size=0x348a
```
> **MB7707_MAC** - необходимо установить соответственно адресу вашей сетевой карты. 
> В дальнейшим в примерах c хост частью будет использоваться адрес 1a-2b-3c-4d-5e-6f, для удобства рекомендуется выставить такой же MAC адрес для сетвой карты.


В конфигурационном файле (mb7707brd.cfg) располагаем секции обмена в разделяемой памяти :
```cfg
MEMORY
{
    EXTERNAL_MEM_BANK0:  at  0x10000000, len = 0x02000000; // 128MB-EM0-DDR (ARM:0x40000000    0x7fffffff) 
}

SEGMENTS
{
    ext_data0    : in EXTERNAL_MEM_BANK0;
}

SECTIONS
{
    //--------- exchange sections -----------------
    .data_shared_src.bss          : in ext_data0;
    .data_shared_dst.bss          : in ext_data0;
}
```

Сборка программы осуществляется командой *make*, запуск - *make run*.   
В результате работы программы должно сформироваться изображение **sobel.pgm**  
![Рис.1](http://savepic.ru/7691336.png)



### Шаг 1-c. Создание nmc-приложения с управляющей хостовой частью. 

Проект состоит из двух частей - хостовой /mb7707/pc и целевой /mb7707/nm.  
Хостовая часть необходима для:  
- загрузки исполняемого NMC-кода на МС77.07 
- чтения  файла src.bmp  
- загрузки ч/б изображения на плату  
- считывание результата обработки с платы  
- сохранения результата в dst.bmp  

Целевая часть ждет получения изображения от хоста и обрабатывает его фильтром Собеля 

Общие файлы (sobel.cpp sobel.h ), которые также используются в сборках для других целевых платформ, лежат в корне папки */step02_easybmp_risc*

#### Создаем целевое NMC-приложение
Работа целевого приложения отличается от standalone приложения, только тем, что файл изображения разбирается на стороне хоста и передается на NMC-часть в виде массива пикслей.
Для барьерной синхронизации используются функции библиотеки загрузки и обмена: **ncl_sync** - на стороне NMC и ответная функция **PL_Sync** - на стороне PC.
Для компактности кода функции загрузки и обмена для PC обенруты в соответствующие методы класса **C_PC_Connector_mb7707** 

#### Создаем host-приложение
Аналогично прописываем пути в Makefile для хост приложения
```
INC_DIRS         = -I"$(MB7707)/pc/include" -I$(ROOT)/deps/connector -I$(ROOT)/deps/EasyBMP
LIB_DIRS         = -L"$(MB7707)/pc/lib"
SRC_DIRS         = .. $(ROOT)/deps/EasyBMP
LIBS             = mb7707load.lib
```
Работу с bmp файлами осуществляем через библиотеку EasyBMP
Доступ к плате для удобства осуществляется через класс **C_PC_Connector_mb7707** , на вход конструктора которого необходимо передать имя исполняемого плата и MAC адрес сетевого контролера к которому подсоединена плата.


В результате исполнения в этой же папке должен появиться dst.bmp

#### Производительность: 
- 1203625826 clocks per frame 
- 14247 clocks per pixel
- 0.265863 fps
